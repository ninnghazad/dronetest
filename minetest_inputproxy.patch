diff --git a/src/guiFormSpecMenu.cpp b/src/guiFormSpecMenu.cpp
index a502c96..5b12b74 100644
--- a/src/guiFormSpecMenu.cpp
+++ b/src/guiFormSpecMenu.cpp
@@ -1231,6 +1231,94 @@ void GUIFormSpecMenu::parseField(parserData* data,std::string element,
 	errorstream<< "Invalid field element(" << parts.size() << "): '" << element << "'"  << std::endl;
 }
 
+
+void GUIFormSpecMenu::parseProxy(parserData* data,std::string element)
+{
+	std::vector<std::string> parts = split(element,';');
+	std::vector<std::string> v_pos = split(parts[0],',');
+	std::vector<std::string> v_geom = split(parts[1],',');
+	std::string name = parts[2];
+	std::string image_name = parts[3];
+	std::string active_image_name = parts[4];
+
+	MY_CHECKPOS("field",0);
+	MY_CHECKGEOM("field",1);
+
+	v2s32 pos;
+	pos.X = stof(v_pos[0]) * (float) spacing.X;
+	pos.Y = stof(v_pos[1]) * (float) spacing.Y;
+
+	v2s32 geom;
+
+	geom.X = (stof(v_geom[0]) * (float)spacing.X)-(spacing.X-imgsize.X);
+	geom.Y = (stof(v_geom[1]) * (float)imgsize.Y) - (spacing.Y-imgsize.Y);
+//	pos.Y += m_btn_height;
+	
+	core::rect<s32> rect = core::rect<s32>(pos.X, pos.Y, pos.X+geom.X, pos.Y+geom.Y+(m_btn_height/2));
+	//core::rect<s32> rect = core::rect<s32>(pos.X, pos.Y, pos.X, pos.Y);
+
+	if(data->bp_set != 2)
+		errorstream<<"WARNING: invalid use of positioned proxy without a size[] element"<<std::endl;
+
+	
+
+	active_image_name = unescape_string(active_image_name);
+	image_name = unescape_string(image_name);
+
+	FieldSpec spec(
+		narrow_to_wide(name.c_str()),
+		narrow_to_wide(image_name.c_str()),
+		narrow_to_wide(active_image_name.c_str()),
+		258+m_fields.size()
+	);
+
+	gui::IGUISkin* skin = Environment->getSkin();
+	gui::IGUIEditBox * _e;
+	
+
+	spec.send = true;
+	_e = Environment->addEditBox(L"-", rect, true, this, spec.fid);
+
+	if (spec.fname == data->focused_fieldname) {
+		Environment->setFocus(_e);
+	}
+
+	irr::SEvent evt;
+	evt.EventType            = EET_KEY_INPUT_EVENT;
+	evt.KeyInput.Key         = KEY_END;
+	evt.KeyInput.Char        = 0;
+	evt.KeyInput.Control     = 0;
+	evt.KeyInput.Shift       = 0;
+	evt.KeyInput.PressedDown = true;
+	_e->OnEvent(evt);
+
+	_e->setDrawBackground(false);
+	_e->setDrawBorder(true
+		
+	);
+	video::SColor color = video::SColor(0,0,0,0);
+	_e->setOverrideColor(color);
+	_e->enableOverrideColor(true);
+	
+	pos = AbsoluteRect.UpperLeftCorner;
+	pos.X += stof(v_pos[0]) * (float) spacing.X;
+	pos.Y += stof(v_pos[1]) * (float) spacing.Y;
+
+	geom.X = stof(v_geom[0]) * (float)imgsize.X;
+	geom.Y = stof(v_geom[1]) * (float)imgsize.Y;
+	Environment->setFocus(_e);
+	
+	// paint a little picture
+	
+	if (spec.fname == data->focused_fieldname) 
+		m_images.push_back(ImageDrawSpec(active_image_name, pos,geom));
+	else
+		m_images.push_back(ImageDrawSpec(image_name, pos,geom));
+ 	
+	spec.ftype = f_Proxy;
+	m_fields.push_back(spec);
+	
+}
 void GUIFormSpecMenu::parseLabel(parserData* data,std::string element)
 {
 	std::vector<std::string> parts = split(element,';');
@@ -1777,6 +1865,11 @@ void GUIFormSpecMenu::parseElement(parserData* data, std::string element)
 		parseField(data,description,type);
 		return;
 	}
+	
+	if (type == "proxy") {
+		parseProxy(data,description);
+		return;
+	}
 
 	if (type == "label") {
 		parseLabel(data,description);
@@ -2653,6 +2746,29 @@ static bool isChild(gui::IGUIElement * tocheck, gui::IGUIElement * parent)
 
 bool GUIFormSpecMenu::preprocessEvent(const SEvent& event)
 {
+	if(event.EventType==EET_KEY_INPUT_EVENT && (event.KeyInput.PressedDown)) {
+		KeyPress kp(event.KeyInput);
+		gui::IGUIElement *focused = Environment->getFocus();
+		if(focused && isMyChild(focused)) {
+			if(focused->getType() == gui::EGUIET_EDIT_BOX && getTypeByID(focused->getID()) == f_Proxy) {
+				((gui::IGUIEditBox*)focused)->setDrawBackground(true);
+				std::ostringstream os;
+				os << event.KeyInput.Key << ":" << (event.KeyInput.Control?1:0) << ":" << (event.KeyInput.Shift?1:0);
+				focused->setText(irr::core::stringw(os.str().c_str()).c_str());
+				acceptInput();
+				return true;
+			}
+		}
+	} else {
+		gui::IGUIElement *focused = Environment->getFocus();
+		if(focused && isMyChild(focused)) {
+			if(focused->getType() == gui::EGUIET_EDIT_BOX && getTypeByID(focused->getID()) == f_Proxy) {
+				((gui::IGUIEditBox*)focused)->setDrawBackground(false);
+			}
+		}
+		
+	}
+	
 	// Fix Esc/Return key being eaten by checkboxen and tables
 	if(event.EventType==EET_KEY_INPUT_EVENT) {
 		KeyPress kp(event.KeyInput);
@@ -2668,6 +2784,7 @@ bool GUIFormSpecMenu::preprocessEvent(const SEvent& event)
 			}
 		}
 	}
+	
 	// Mouse wheel events: send to hovered element instead of focused
 	if(event.EventType==EET_MOUSE_INPUT_EVENT
 			&& event.MouseInput.Event == EMIE_MOUSE_WHEEL) {
@@ -3392,3 +3509,19 @@ std::wstring GUIFormSpecMenu::getLabelByID(s32 id)
 	}
 	return L"";
 }
+
+/**
+ * get ftype of element by element id
+ * @param id of element
+ * @return FormSpecFieldType or f_Unknown
+ */
+FormspecFieldType GUIFormSpecMenu::getTypeByID(s32 id)
+{
+	for(std::vector<FieldSpec>::iterator iter =  m_fields.begin();
+				iter != m_fields.end(); iter++) {
+		if (iter->fid == id) {
+			return iter->ftype;
+		}
+	}
+	return f_Unknown;
+}
diff --git a/src/guiFormSpecMenu.h b/src/guiFormSpecMenu.h
index 40be59b..59ed2cb 100644
--- a/src/guiFormSpecMenu.h
+++ b/src/guiFormSpecMenu.h
@@ -42,6 +42,7 @@ typedef enum {
 	f_CheckBox,
 	f_DropDown,
 	f_ScrollBar,
+	f_Proxy,
 	f_Unknown
 } FormspecFieldType;
 
@@ -388,7 +389,9 @@ class GUIFormSpecMenu : public GUIModalMenu
 	void parseDropDown(parserData* data,std::string element);
 	void parsePwdField(parserData* data,std::string element);
 	void parseField(parserData* data,std::string element,std::string type);
+	
 	void parseSimpleField(parserData* data,std::vector<std::string> &parts);
+	void parseProxy(parserData* data,std::string element);
 	void parseTextArea(parserData* data,std::vector<std::string>& parts,
 			std::string type);
 	void parseLabel(parserData* data,std::string element);
@@ -421,6 +424,7 @@ class GUIFormSpecMenu : public GUIModalMenu
 
 	std::wstring getLabelByID(s32 id);
 	std::wstring getNameByID(s32 id);
+	FormspecFieldType getTypeByID(s32 id);
 #ifdef __ANDROID__
 	v2s32 m_down_pos;
 	std::wstring m_JavaDialogFieldName;
