-- quarry demo
local droneid = 1
local posMin = {x=-10,y=-200,z=-10}
local posMax =  {x=10,y=0,z=10}
local ignore = {"default:stone"}




local channel = "dronetest:drone:"..droneid
local drone = peripheral.wrap(channel)
local rz = math.ceil((math.abs(posMax.y - posMin.y)+1)/3)
local ry = math.abs(posMax.z - posMin.z)+1
local rx = math.abs(posMax.x - posMin.x)+1
local dir = {}
local totalBlocks = rz*ry*rx
local x,y,z,r
local startTime = sys.time()/20
local start = 0 

pos = dronetest.drones[droneid].object:getpos()
direction = dronetest.yaw2dir(dronetest.snapRotation(dronetest.drones[droneid].object:getyaw()))

posMin.x = posMin.x + pos.x
posMin.y = posMin.y + pos.y
posMin.z = posMin.z + pos.z
posMax.x = posMax.x + pos.x
posMax.y = posMax.y + pos.y
posMax.z = posMax.z + pos.z

local xDirs = { }
xDirs[0] = 0
xDirs[1] = 1
xDirs[2] = 0
xDirs[3] = -1
xDirs[4] = 0
xDirs[5] = 0
local yDirs = { }
yDirs[0] = -1
yDirs[1] = 0
yDirs[2] = 1
yDirs[3] = 0
yDirs[4] = 0
yDirs[5] = 0
local zDirs = { }
zDirs[0] = 0
zDirs[1] = 0
zDirs[2] = 0
zDirs[3] = 0
zDirs[4] = 1
zDirs[5] = -1
xDir = xDirs[direction]
yDir = yDirs[direction]

function getDirection(x , y , z)
	if y > 0 then
		return 2
	elseif y < 0 then
		return 0
	elseif x > 0 then
		return 1
	elseif x < 0 then
		return 3
	elseif z ~= nil and z > 0 then
		return 4	
	elseif z ~= nil and z < 0 then
		return 5
	else
		print("bug: invalid direction "..x..","..y)
		return -1
	end
end

function turnDir(newXDir,newYDir)
	local rot = (getDirection(xDir,yDir,0) - getDirection(newXDir,newYDir,0))
	-- Make sure we use the shortest direction to get where we want
	if rot > 2 then
		rot = rot - 4
	elseif rot < -2 then
		rot = rot + 4
	end
	while rot ~= 0 do
		if rot < 0 then
			drone.turnLeft()
			rot = rot + 1
		end
		if rot > 0 then
			drone.turnRight()
			rot = rot - 1
		end
	end
	xDir = newXDir
	yDir = newYDir
end

function turnRot(dir)
	if dir < 4 then
		turnDir(xDirs[dir],yDirs[dir],0)
	end
end

function goDir(dir)
	direction = dir
	
	if dir == 4 then return drone.up()
	elseif dir == 5 then return drone.down()
	else turnRot(dir) return drone.forward() end
end

function digDir(dir,pickup)
	direction = dir
	xDir = xDirs[dir]
	yDir = yDirs[dir]
	if dir == 4 then return drone.digUp(pickup)
	elseif dir == 5 then return drone.digDown(pickup)
	else turnRot(dir) return drone.dig(pickup) end
end

function digTo(target,pickup)
	local dir = -1
	local counter = 0
	while pos.x ~= target.x or pos.z ~= target.z or pos.y ~= target.y do
		
		if pos.y < target.y then dir = 4
		elseif pos.y > target.y then dir = 5
		elseif pos.z < target.z then dir = 2
		elseif pos.z > target.z then dir = 0
		elseif pos.x < target.x then dir = 1
		else dir = 3 end
		
		local r,t = goDir(dir)
		if not r then
			digDir(dir,pickup)
			r,t = goDir(dir)
			if not r then
				return false
			end
		end

		pos.x = pos.x + xDirs[dir]
		pos.z = pos.z + yDirs[dir]
		pos.y = pos.y + zDirs[dir]
	end
	return true
end
local function shouldDig(name)
	if type(name) ~= "string" then return false end
	for _,ign in ipairs(ignore) do
		if ign == name then
			return false
		end
	end
	return true
end
local digged = {}
local function addToDigged(name)
	if name == nil then return nil end
	if digged[name] == nil then digged[name] = 1
	else digged[name] = digged[name] + 1 end
	return digged[name]
end

local skip = 0
local target
local name
local dig
for i = start,totalBlocks-1,1 do
	dig = true
	x = (i % rx) + 1
	y = (((i-x+1) / rx) % ry) + 1
	z = (((i-(i%(rx*ry))) / (rx*ry)) * 3) + 1
	if z % 2 == 1 then
		y = ry+1-y
		x = rx+1-x
	end
	if y % 2 ~= 1 then
		x = rx+1-x
	end
	
	x = x + posMin.x - 1
	y = y + posMin.z - 1
	z = (posMax.y - z) 
	
	if z < posMin.y then z = posMin.y end
	if z > posMax.y then z = posMax.y end
	target = {x=x,y=z,z=y+skip}
		
	if addToDigged(digTo(target,shouldDig(drone.inspect()))) then 
		if z < posMax.y and shouldDig(drone.inspectUp()) then addToDigged(drone.digUp(true)) end
		if z > posMin.y and shouldDig(drone.inspectDown()) then addToDigged(drone.digDown(true)) end
		
		if skip > 0 then skip = skip - 1 end
	else 
		print("could not dig to "..x..","..y..","..z)
		return false
	end

end
print(dump(digged))
return true